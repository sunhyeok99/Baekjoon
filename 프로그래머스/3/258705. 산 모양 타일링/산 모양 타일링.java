class Solution {
    public int solution(int n, int[] tops) {
        int answer = 0;
        // dp 문제 같음
        // 모든 블럭들을 좌표로 인식해서 dp풀어보자
        int[][] dp = new int[n][2];
        // 일단 짤라서 생각해보면 오른쪽 밑에 블럭이 채워지지 않은 경우의수 + 채워진 경우의 수로 나눌 수 있음
        // 채워지지 않았으면 위에가 없다면 블럭이 늘어날때마다 2가지 경우의 수로 나눠짐 -> 2 (마름모 쓰거나 안쓰거나)
        // 채워진경우는 무조건 1개로 나뉨 ( 마름모 쓰는경우)
        // n=1는 총 3(2+1) , n=2은 총 8(5(2*2+1)+3(n=1일때 개수)) 이런식으로 이뤄짐
        
        // 만약 top이 있다면 마름모가 안채워졌을 경우만 +되는데 
        // 전항이 마름모x 일때에서 3가지가 가능하고 , 마름모o이면 2가지(기존에는 삼각형만가능하지만 마름모 가능)로 가능
        
        // 적용시작
        
        dp[0][0] = 2 + tops[0];
        dp[0][1] = 1;
        for(int i = 1;i< n;i++){
            // 전항꺼에서 더하기 계속
            dp[i][0] = dp[i-1][0] *(2+ tops[i]) + dp[i-1][1] * (1+ tops[i]);
            dp[i][0] %= 10007;
            dp[i][1] = dp[i-1][0] + dp[i-1][1];
            dp[i][1] %= 10007;
        }
        answer += dp[n-1][0] + dp[n-1][1];
        
        
        return answer%10007;
    }
}